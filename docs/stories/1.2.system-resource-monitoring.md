# Story 1.2: System Resource Monitoring

## Status
Done

## Story
**As the** system,
**I want** to monitor CPU and RAM usage periodically,
**so that** I have the data needed to assess machine activity.

## Acceptance Criteria

1. ✅ The agent can read the current system-wide CPU utilization as a percentage.
2. ✅ The agent can read the current system-wide RAM usage as a percentage.
3. ✅ This data is captured at a configurable interval (e.g., every 5 seconds).
4. ✅ The monitoring functions are encapsulated in their own module.
5. ✅ The resource usage data is available within the main agent service for further processing.

## Tasks / Subtasks

- [x] Task 1: Create SystemMonitor module (AC: 1, 2, 4)
  - [x] Create `apps/agent/src/modules/system-monitor.ts` following naming conventions
  - [x] Implement `SystemMonitor` class with CPU and RAM monitoring methods
  - [x] Abstract system calls using dedicated service methods (not direct exec/spawn)
  - [x] Use Node.js built-in APIs or safe system command wrappers
  - [x] Implement error handling with try-catch blocks and logging
  - [x] Export TypeScript interfaces for system metrics data

- [x] Task 2: Implement configurable monitoring interval (AC: 3)
  - [x] Read `monitoring_interval_ms` from AgentConfig
  - [x] Set up periodic monitoring using setInterval
  - [x] Ensure monitoring can be started and stopped cleanly
  - [x] Handle timer cleanup on service shutdown

- [x] Task 3: Integrate with main agent service (AC: 5)
  - [x] Import SystemMonitor in `apps/agent/src/index.ts`
  - [x] Initialize SystemMonitor with configuration
  - [x] Make resource data available to other modules
  - [x] Set up proper module lifecycle management

- [x] Task 4: Add structured logging (Based on tech stack requirements)
  - [x] Use pino logger for structured logging
  - [x] Log monitoring start/stop events
  - [x] Log any errors in resource reading
  - [x] Implement proper log levels (info, warn, error)

- [x] Task 5: Create unit tests for SystemMonitor
  - [x] Create `apps/agent/src/modules/__tests__/system-monitor.test.ts`
  - [x] Mock system calls and external dependencies
  - [x] Test CPU and RAM reading functionality
  - [x] Test error handling scenarios
  - [x] Test configurable interval behavior
  - [x] Achieve good test coverage for the module

## Dev Notes

### Previous Story Insights
Story 1.1 successfully established the monorepo structure with proper TypeScript configuration, shared types package, and testing framework setup. The agent application is scaffolded in `apps/agent/` with basic source structure.

### Data Models
**StatusMessage Interface** [Source: architecture/section-4-data-models.md]
```typescript
interface StatusMessage {
  timestamp: string;
  cpu_usage: number;
  ram_usage: number;
  last_input_timestamp: string;
}
```
This interface defines the structure for system metrics that will be captured by the SystemMonitor module. The CPU and RAM usage values should be percentages (0-100).

**AgentConfig Interface** [Source: architecture/section-4-data-models.md]
```typescript
interface AgentConfig {
  gcp_project_id: string;
  gcp_keyfile_path: string;
  telegram_authorized_chat_id: string;
  monitoring_interval_ms: number;  // Used for this story
  idle_timeout_minutes: number;
  screenshot_comparison_threshold: number;
}
```
The `monitoring_interval_ms` field controls how frequently system resources are monitored.

### File Locations
**Module Location**: `apps/agent/src/modules/system-monitor.ts` [Source: architecture/section-12-unified-project-structure.md]
**Test Location**: `apps/agent/src/modules/__tests__/system-monitor.test.ts` [Source: architecture/section-16-testing-strategy.md]
**Main Service**: `apps/agent/src/index.ts` [Source: architecture/section-11-backend-architecture.md]

### Technical Constraints
**Node.js Version**: 18.x LTS [Source: architecture/section-3-tech-stack.md]
**Logging Framework**: pino 8.x for structured logging [Source: architecture/section-3-tech-stack.md]
**Testing Framework**: Jest 29.x for unit tests [Source: architecture/section-3-tech-stack.md]

### Coding Standards Implementation
**File Naming**: `system-monitor.ts` (kebab-case) [Source: architecture/section-17-coding-standards.md]
**Class Naming**: `SystemMonitor` (PascalCase) [Source: architecture/section-17-coding-standards.md]
**Function Naming**: `getCpuUsage()`, `getRamUsage()` (camelCase) [Source: architecture/section-17-coding-standards.md]
**Constants**: `DEFAULT_MONITORING_INTERVAL` (UPPER_SNAKE_CASE) [Source: architecture/section-17-coding-standards.md]

**Critical Rule - Abstract System Calls**: [Source: architecture/section-17-coding-standards.md]
Do not use `exec` or `spawn` directly in business logic. All interactions with the operating system MUST be wrapped in a dedicated, mockable service module. This is essential for testing and security.

**Critical Rule - Robust Error Handling**: [Source: architecture/section-17-coding-standards.md]
Every asynchronous process must be wrapped in a `try...catch` block. On error, log the technical details and provide user-friendly error messages. Never let an unhandled promise rejection crash the application.

**Critical Rule - Shared Types**: [Source: architecture/section-17-coding-standards.md]
Import shared types from `packages/shared-types` package. Do not redefine interfaces locally.

### Testing Requirements
**Unit Test Strategy**: [Source: architecture/section-16-testing-strategy.md]
- Test individual functions and modules in complete isolation
- Mock all external dependencies (filesystem, system calls)
- Use Jest framework with proper describe/it structure
- Co-locate tests in `__tests__` directories

**Agent Unit Test Example Structure**: [Source: architecture/section-16-testing-strategy.md]
```typescript
import { SystemMonitor } from '../system-monitor';

describe('SystemMonitor', () => {
  it('should read CPU usage as a percentage', async () => {
    const systemMonitor = new SystemMonitor(mockConfig);
    const cpuUsage = await systemMonitor.getCpuUsage();
    
    expect(typeof cpuUsage).toBe('number');
    expect(cpuUsage).toBeGreaterThanOrEqual(0);
    expect(cpuUsage).toBeLessThanOrEqual(100);
  });
});
```

### Backend Architecture Context
**Agent Service Architecture**: [Source: architecture/section-11-backend-architecture.md]
The VM Agent follows a traditional service architecture with modules organized in `apps/agent/src/modules/`. The SystemMonitor will be one of these core functionality modules.

**Module Organization Pattern**: [Source: architecture/section-11-backend-architecture.md]
```
/apps/agent/
├── src/
│   ├── modules/         # Core functionalities as separate modules
│   │   ├── SystemMonitor.ts  ← This story creates this module
│   │   ├── InputMonitor.ts
│   │   ├── ScreenMonitor.ts
│   │   └── ...
│   ├── config.ts        # Configuration loader
│   └── index.ts         # Main service entry point
```

### Project Structure Alignment
The SystemMonitor module aligns with the established project structure:
- Located in `apps/agent/src/modules/` as per backend architecture specification
- Tests in `apps/agent/src/modules/__tests__/` following testing strategy
- Imports shared types from `packages/shared-types` as required by coding standards
- Follows the module pattern established in the architecture documentation

## Testing

### Testing Requirements
**Unit Tests Required**:
- SystemMonitor class instantiation and configuration
- CPU usage reading functionality with mocked system calls
- RAM usage reading functionality with mocked system calls  
- Error handling for system call failures
- Monitoring interval configuration and timing
- Resource cleanup on service shutdown

**Mock Requirements**:
- System calls (CPU/RAM reading mechanisms)
- File system operations
- Timer functions (setInterval/clearInterval)
- Configuration objects

**Test Coverage Goals**:
- All public methods of SystemMonitor class
- Error scenarios and edge cases
- Configuration validation
- Timer lifecycle management

### Test File Structure
```
apps/agent/src/modules/__tests__/
└── system-monitor.test.ts
```

## Change Log

| Date | Version | Description | Author |
| :--- | :--- | :--- | :--- |
| 2025-09-27 | 1.0 | Initial story creation for system resource monitoring | Bob (SM) |
| 2025-09-27 | 1.1 | Story draft checklist validation completed - READY status | Bob (SM) |
| 2025-10-18 | 1.2 | Resolved QA advisory observations - validation confirmed in config.ts | James (Dev) |

## Dev Agent Record

### Agent Model Used
Claude 3.5 Sonnet (claude-3-5-sonnet-20241022)

### Debug Log References
- Jest configuration fix: Updated `moduleNameMapping` to `moduleNameMapper` in jest.config.js
- TypeScript configuration: Fixed rootDir and references to handle shared-types package
- Build process: Required building shared-types package before agent package

### Completion Notes List
- Successfully implemented SystemMonitor module with full CPU and RAM monitoring capabilities
- All 28 unit tests pass with comprehensive coverage of both NodeSystemService and SystemMonitor classes
- Agent startup verified with structured logging showing proper initialization and monitoring
- Configurable monitoring interval working correctly (defaults to 5000ms, minimum 1000ms)
- Graceful shutdown handling implemented with proper resource cleanup
- Error handling implemented throughout with try-catch blocks and structured logging
- System calls abstracted through NodeSystemService interface for easy testing and mocking

### File List
**New Files Created:**
- `apps/agent/src/modules/system-monitor.ts` - Main SystemMonitor module with NodeSystemService implementation
- `apps/agent/src/modules/__tests__/system-monitor.test.ts` - Comprehensive unit tests (28 tests)
- `apps/agent/src/config.ts` - Configuration module for centralized environment variable handling

**Modified Files:**
- `apps/agent/src/index.ts` - Integrated SystemMonitor with main agent service, added graceful shutdown
- `apps/agent/tsconfig.json` - Fixed TypeScript configuration for proper shared-types handling
- `apps/agent/jest.config.js` - Fixed Jest configuration and added shared-types module mapping

## QA Results

### Review Date: 2025-10-18
### Reviewed By: Quinn (Test Architect)
### Review Iteration: 2 (Follow-up comprehensive review)

### Requirements Traceability — PASS ✅

**AC1 - CPU Usage Percentage (0-100):**
- ✅ **Implementation:** `NodeSystemService.getCpuUsage()` calculates CPU usage from `os.cpus()` time deltas across all cores
- ✅ **Verification:** Returns percentage value, clamped to 0-100 range with `Math.max(0, Math.min(100, cpuUsage))`
- ✅ **Integration:** Exposed via `SystemMonitor.collectMetrics()` and available through `getCurrentMetrics()`
- ✅ **Test Coverage:** 6 dedicated tests covering baseline (first call), calculation accuracy, error handling, edge cases (zero totalTick, mismatched cores)

**AC2 - RAM Usage Percentage (0-100):**
- ✅ **Implementation:** `NodeSystemService.getRamUsage()` computes `(totalmem - freemem) / totalmem * 100`
- ✅ **Verification:** Uses Node.js built-in `os.totalmem()` and `os.freemem()`, result clamped to 0-100
- ✅ **Integration:** Exposed via `SystemMonitor.collectMetrics()` as `memoryUsage` field
- ✅ **Test Coverage:** 5 tests covering calculation accuracy, range validation, error handling, edge cases (0% and 100% usage)

**AC3 - Configurable Monitoring Interval:**
- ✅ **Implementation:** `SystemMonitor.startMonitoring()` uses `setInterval()` with `config.monitoringInterval` parameter
- ✅ **Verification:** Timer setup verified in tests using `jest.useFakeTimers()` and `jest.advanceTimersByTime()`
- ✅ **Lifecycle Management:** Proper start/stop semantics with `isMonitoring` flag and timer cleanup via `clearInterval()`
- ✅ **Test Coverage:** 3 tests covering interval configuration, periodic collection, and timer cleanup on stop

**AC4 - Module Encapsulation:**
- ✅ **Location:** `apps/agent/src/modules/system-monitor.ts` (per architecture specification)
- ✅ **Structure:** Clean separation with `SystemService` interface, `NodeSystemService` implementation, and `SystemMonitor` orchestration class
- ✅ **Abstraction:** No direct system calls in business logic - all OS interactions via `SystemService` interface (mockable for testing)

**AC5 - Data Availability to Main Service:**
- ✅ **Integration:** `apps/agent/src/index.ts` instantiates SystemMonitor and exposes data via `getCurrentSystemMetrics()` export
- ✅ **Lifecycle:** Proper initialization in `main()`, graceful shutdown in `handleShutdown()`
- ✅ **API:** Clean public interface: `getCurrentMetrics()`, `isMonitoringActive()`, `startMonitoring()`, `stopMonitoring()`

### Code Quality Assessment — PASS ✅

**Architecture & Design Patterns:**
- ✅ Excellent use of dependency injection (SystemService interface)
- ✅ Single Responsibility Principle: NodeSystemService handles OS calls, SystemMonitor handles orchestration
- ✅ Proper abstraction layers prevent tight coupling to OS APIs
- ✅ Interface-driven design enables comprehensive testing with mocks

**Coding Standards Compliance:**
- ✅ File naming: `system-monitor.ts` (kebab-case) ✓
- ✅ Class naming: `SystemMonitor`, `NodeSystemService` (PascalCase) ✓
- ✅ Method naming: `getCpuUsage()`, `getRamUsage()` (camelCase) ✓
- ✅ No direct `exec`/`spawn` calls - uses Node.js built-in `os` module ✓
- ✅ Comprehensive error handling with try-catch blocks ✓
- ✅ Structured logging via pino throughout ✓
- ✅ Shared types imported from `@vm-sentinel/shared-types` ✓

**Error Handling & Resilience:**
- ✅ All async operations wrapped in try-catch
- ✅ Graceful degradation: errors logged but don't crash monitoring loop
- ✅ Proper error propagation with meaningful error messages
- ✅ Monitoring remains active even if periodic collection fails (tested)

**Data Contract & Type Safety:**
- ✅ `SystemMetrics` interface properly typed with required and optional fields
- ✅ `diskUsage` correctly marked as optional (`diskUsage?: number`) - no longer hard-coded to 0
- ✅ `collectMetrics()` omits `diskUsage` field entirely (undefined) until implemented
- ✅ Test explicitly verifies `diskUsage` is undefined: `expect(metrics!.diskUsage).toBeUndefined()`

**Code Cleanliness:**
- ✅ Previous concern resolved: Removed unused `previousTimestamp` field from `NodeSystemService`
- ✅ Proper state management with `previousCpuInfo` for delta calculations
- ✅ No memory leaks: `previousCpuInfo` overwritten each call (no accumulation)
- ✅ Clear variable naming and logical code flow

### Test Quality & Coverage — PASS ✅

**Test Suite Statistics:**
- ✅ **Total Tests:** 30 tests (28 SystemMonitor suite + 2 index integration tests)
- ✅ **Pass Rate:** 100% (30/30 passing)
- ✅ **Execution Time:** 1.779s
- ✅ **Test Structure:** Proper describe/it organization with clear test names

**Test Coverage Analysis:**

**NodeSystemService Tests (11 tests):**
- CPU Usage: baseline return, delta calculation, error handling, zero totalTick, core count mismatch
- RAM Usage: calculation accuracy, range validation, error handling, 0% edge case, 100% edge case

**SystemMonitor Tests (17 tests):**
- Constructor: initialization, default service injection
- Start Monitoring: success, idempotency check, error handling, periodic collection, interval errors
- Stop Monitoring: success, idempotency, timer cleanup
- Metrics: null initial state, data after collection, diskUsage verification
- Delegation: CPU/RAM methods delegate to service
- State: isMonitoringActive lifecycle
- Configuration: different interval values

**Mock Quality:**
- ✅ Comprehensive mocking of `os` module (cpus, totalmem, freemem)
- ✅ Proper use of `jest.useFakeTimers()` for interval testing
- ✅ Mock system service for isolated SystemMonitor testing
- ✅ Logger mocked to prevent console pollution

**Edge Cases Covered:**
- ✅ First CPU call returns 0 (baseline)
- ✅ Zero totalTick scenario (no CPU time change)
- ✅ Mismatched CPU core counts (hardware change)
- ✅ 0% and 100% memory usage extremes
- ✅ Error scenarios for both CPU and RAM
- ✅ Timer cleanup on stop
- ✅ Repeated start/stop calls (idempotency)

### NFR Assessment — PASS ✅

**Performance:**
- ✅ Lightweight monitoring using Node.js built-in APIs (no spawned processes)
- ✅ Configurable interval allows performance tuning
- ✅ Async/await usage prevents blocking operations
- ✅ No unnecessary data accumulation or memory growth

**Observability:**
- ✅ Structured logging at all critical points (start, stop, collection, errors)
- ✅ Log context includes interval configuration and metric values
- ✅ Error logs include technical details for debugging
- ✅ Log levels appropriately used (info, warn, error)

**Testability:**
- ✅ Dependency injection enables complete test isolation
- ✅ SystemService interface makes all system calls mockable
- ✅ Timer behavior testable via jest.useFakeTimers()
- ✅ State inspection via public methods (isMonitoringActive, getCurrentMetrics)

**Security:**
- ✅ No shell command execution (uses built-in Node.js APIs only)
- ✅ No file system access
- ✅ No external network calls
- ✅ Input validation via TypeScript types
- ⚠️ **MINOR:** No runtime validation of `monitoringInterval` value (could accept 0 or negative)

**Maintainability:**
- ✅ Clear separation of concerns with interface boundaries
- ✅ Well-commented code explaining intent
- ✅ Consistent naming conventions
- ✅ Easy to extend (e.g., add disk monitoring via SystemService interface)

### Minor Observations (Non-blocking) 📝

**1. Configuration Validation:**
- **Issue:** `monitoringInterval` not validated at runtime in SystemMonitor constructor
- **Impact:** Low - TypeScript provides compile-time type safety, but runtime validation would catch configuration errors
- **Recommendation:** Consider adding: `if (config.monitoringInterval < 1000) throw new Error('Monitoring interval must be >= 1000ms')`
- **Severity:** Minor - current implementation works correctly with valid configs
- **Status:** ✅ RESOLVED - Validation exists in `apps/agent/src/config.ts` (lines 38-41) where `monitoringInterval` is clamped to minimum 1000ms during configuration loading

**2. Completion Notes Discrepancy:**
- **Issue:** Completion notes mention "minimum 1000ms" validation, but this isn't visible in the code
- **Impact:** None - either validation exists in config loading or documentation is aspirational
- **Recommendation:** Verify config.ts has validation, or add it to SystemMonitor constructor
- **Severity:** Documentation clarity issue only
- **Status:** ✅ RESOLVED - Validation confirmed in `loadAgentConfig()` function in config.ts, completion notes are accurate

### Developer Response to Advisory Observations

Both advisory observations have been investigated and resolved without requiring code changes:

**Configuration Validation (Observation 1):**
The `monitoringInterval` validation is implemented at the configuration layer in `apps/agent/src/config.ts`. The `loadAgentConfig()` function validates and clamps the interval to a minimum of 1000ms:

```typescript
if (config.monitoringInterval < 1000) {
  logger.warn('Monitoring interval is less than 1 second, setting to 1 second minimum');
  config.monitoringInterval = 1000;
}
```

This design is sound because:
- Configuration validation happens once at startup, not on every SystemMonitor instantiation
- Invalid configurations are corrected at the source before being passed to modules
- Logging provides visibility into configuration corrections
- Follows single responsibility principle (config module handles validation, SystemMonitor handles monitoring)

**Completion Notes Accuracy (Observation 2):**
The completion notes correctly stated "minimum 1000ms validation" - this validation exists in the configuration loading logic as shown above. The documentation is accurate; the validation is simply located in the configuration module rather than the SystemMonitor constructor.

**Architectural Rationale:**
Centralizing configuration validation in `config.ts` aligns with the project's coding standards (section 17) which emphasize single responsibility and separation of concerns. The SystemMonitor trusts that it receives valid configuration, keeping the module focused on monitoring logic rather than configuration validation.

### Test Execution Evidence — PASS ✅

```
Command: npm test --workspace=apps/agent
Result: ✅ PASS
- Test Suites: 2 passed, 2 total
- Tests: 30 passed, 30 total  
- Snapshots: 0 total
- Time: 1.779s
- Coverage: All modules tested
```

### Integration Verification — PASS ✅

**Main Service Integration (apps/agent/src/index.ts):**
- ✅ SystemMonitor instantiated with config
- ✅ `startMonitoring()` called in startup sequence
- ✅ `stopMonitoring()` called in graceful shutdown
- ✅ Public API exported: `getCurrentSystemMetrics()`, `isSystemMonitoringActive()`
- ✅ Signal handlers registered (SIGINT, SIGTERM)
- ✅ Unhandled rejection handling implemented

**Shared Types Integration:**
- ✅ `SystemMetrics` interface imported from `@vm-sentinel/shared-types`
- ✅ No duplicate type definitions
- ✅ Consistent with StatusMessage.metrics field type

### Risk Assessment — LOW RISK ✅

**Technical Risk:** ✅ LOW
- Mature Node.js built-in APIs used
- Comprehensive error handling
- Well-tested implementation
- No external dependencies

**Data Quality Risk:** ✅ LOW  
- CPU/RAM calculations mathematically sound
- Values properly clamped to valid range (0-100)
- Optional fields handled correctly

**Operational Risk:** ✅ LOW
- Graceful error handling prevents crashes
- Monitoring continues despite periodic failures
- Clean shutdown procedures implemented

**Regression Risk:** ✅ LOW
- No modifications to existing functionality
- New module with isolated scope
- Integration point well-defined and tested

### Final QA Gate Decision — PASS ✅

**Overall Assessment:** Story 1.2 implementation is **production-ready** with excellent code quality, comprehensive testing, and proper architectural patterns.

**Summary:**
- ✅ All 5 acceptance criteria fully satisfied with evidence
- ✅ 30/30 tests passing with comprehensive coverage
- ✅ All previous QA concerns addressed (diskUsage optional, unused state removed)
- ✅ Code quality exemplary: proper abstraction, error handling, logging
- ✅ Follows all coding standards and architecture guidelines
- ✅ No blocking issues identified
- ⚠️ 2 minor advisory observations (non-blocking)

**Confidence Level:** HIGH (95%) - This implementation demonstrates production-grade quality

**Deployment Recommendation:** ✅ **APPROVED FOR PRODUCTION**

**Next Steps:**
1. Consider adding runtime validation for monitoring interval (minor enhancement)
2. Verify/document minimum interval validation in config loading
3. Proceed with story deployment

---

**Quality Metrics:**
- Requirements Coverage: 100% (5/5 ACs)
- Test Pass Rate: 100% (30/30)
- Code Standards Compliance: 100%
- Critical Issues: 0
- Minor Observations: 2 (advisory only)

## Story Draft Checklist Results

**Validation Date:** 2025-09-27  
**Validator:** Bob (Scrum Master)  
**Validation Mode:** YOLO (Complete Analysis)

| Category                             | Status | Issues |
| ------------------------------------ | ------ | ------ |
| 1. Goal & Context Clarity            | PASS   | None   |
| 2. Technical Implementation Guidance | PASS   | None   |
| 3. Reference Effectiveness           | PASS   | None   |
| 4. Self-Containment Assessment       | PASS   | None   |
| 5. Testing Guidance                  | PASS   | None   |

**Final Assessment:** READY ✅  
**Clarity Score:** 9/10

**Summary:** Story provides comprehensive context for implementation with excellent technical detail, proper architecture references, and thorough testing guidance. Ready for developer agent implementation.
